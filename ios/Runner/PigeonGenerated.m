// Autogenerated from Pigeon (v16.0.5), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#import "PigeonGenerated.h"

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

static NSArray *wrapResult(id result, FlutterError *error) {
  if (error) {
    return @[
      error.code ?: [NSNull null], error.message ?: [NSNull null], error.details ?: [NSNull null]
    ];
  }
  return @[ result ?: [NSNull null] ];
}

static FlutterError *createConnectionError(NSString *channelName) {
  return [FlutterError errorWithCode:@"channel-error" message:[NSString stringWithFormat:@"%@/%@/%@", @"Unable to establish connection on channel: '", channelName, @"'."] details:@""];
}

static id GetNullableObjectAtIndex(NSArray *array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}

@interface AudioData ()
+ (AudioData *)fromList:(NSArray *)list;
+ (nullable AudioData *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PlaybackState ()
+ (PlaybackState *)fromList:(NSArray *)list;
+ (nullable PlaybackState *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface BackgroundSound ()
+ (BackgroundSound *)fromList:(NSArray *)list;
+ (nullable BackgroundSound *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface Speed ()
+ (Speed *)fromList:(NSArray *)list;
+ (nullable Speed *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface Track ()
+ (Track *)fromList:(NSArray *)list;
+ (nullable Track *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@implementation AudioData
+ (instancetype)makeWithUrl:(NSString *)url
    track:(Track *)track {
  AudioData* pigeonResult = [[AudioData alloc] init];
  pigeonResult.url = url;
  pigeonResult.track = track;
  return pigeonResult;
}
+ (AudioData *)fromList:(NSArray *)list {
  AudioData *pigeonResult = [[AudioData alloc] init];
  pigeonResult.url = GetNullableObjectAtIndex(list, 0);
  pigeonResult.track = [Track nullableFromList:(GetNullableObjectAtIndex(list, 1))];
  return pigeonResult;
}
+ (nullable AudioData *)nullableFromList:(NSArray *)list {
  return (list) ? [AudioData fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.url ?: [NSNull null],
    (self.track ? [self.track toList] : [NSNull null]),
  ];
}
@end

@implementation PlaybackState
+ (instancetype)makeWithIsPlaying:(BOOL )isPlaying
    isBuffering:(BOOL )isBuffering
    isSeeking:(BOOL )isSeeking
    isCompleted:(BOOL )isCompleted
    position:(NSInteger )position
    duration:(NSInteger )duration
    speed:(Speed *)speed
    volume:(NSInteger )volume
    track:(Track *)track
    backgroundSound:(nullable BackgroundSound *)backgroundSound {
  PlaybackState* pigeonResult = [[PlaybackState alloc] init];
  pigeonResult.isPlaying = isPlaying;
  pigeonResult.isBuffering = isBuffering;
  pigeonResult.isSeeking = isSeeking;
  pigeonResult.isCompleted = isCompleted;
  pigeonResult.position = position;
  pigeonResult.duration = duration;
  pigeonResult.speed = speed;
  pigeonResult.volume = volume;
  pigeonResult.track = track;
  pigeonResult.backgroundSound = backgroundSound;
  return pigeonResult;
}
+ (PlaybackState *)fromList:(NSArray *)list {
  PlaybackState *pigeonResult = [[PlaybackState alloc] init];
  pigeonResult.isPlaying = [GetNullableObjectAtIndex(list, 0) boolValue];
  pigeonResult.isBuffering = [GetNullableObjectAtIndex(list, 1) boolValue];
  pigeonResult.isSeeking = [GetNullableObjectAtIndex(list, 2) boolValue];
  pigeonResult.isCompleted = [GetNullableObjectAtIndex(list, 3) boolValue];
  pigeonResult.position = [GetNullableObjectAtIndex(list, 4) integerValue];
  pigeonResult.duration = [GetNullableObjectAtIndex(list, 5) integerValue];
  pigeonResult.speed = [Speed nullableFromList:(GetNullableObjectAtIndex(list, 6))];
  pigeonResult.volume = [GetNullableObjectAtIndex(list, 7) integerValue];
  pigeonResult.track = [Track nullableFromList:(GetNullableObjectAtIndex(list, 8))];
  pigeonResult.backgroundSound = [BackgroundSound nullableFromList:(GetNullableObjectAtIndex(list, 9))];
  return pigeonResult;
}
+ (nullable PlaybackState *)nullableFromList:(NSArray *)list {
  return (list) ? [PlaybackState fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.isPlaying),
    @(self.isBuffering),
    @(self.isSeeking),
    @(self.isCompleted),
    @(self.position),
    @(self.duration),
    (self.speed ? [self.speed toList] : [NSNull null]),
    @(self.volume),
    (self.track ? [self.track toList] : [NSNull null]),
    (self.backgroundSound ? [self.backgroundSound toList] : [NSNull null]),
  ];
}
@end

@implementation BackgroundSound
+ (instancetype)makeWithUri:(nullable NSString *)uri
    title:(NSString *)title {
  BackgroundSound* pigeonResult = [[BackgroundSound alloc] init];
  pigeonResult.uri = uri;
  pigeonResult.title = title;
  return pigeonResult;
}
+ (BackgroundSound *)fromList:(NSArray *)list {
  BackgroundSound *pigeonResult = [[BackgroundSound alloc] init];
  pigeonResult.uri = GetNullableObjectAtIndex(list, 0);
  pigeonResult.title = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable BackgroundSound *)nullableFromList:(NSArray *)list {
  return (list) ? [BackgroundSound fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.uri ?: [NSNull null],
    self.title ?: [NSNull null],
  ];
}
@end

@implementation Speed
+ (instancetype)makeWithSpeed:(double )speed {
  Speed* pigeonResult = [[Speed alloc] init];
  pigeonResult.speed = speed;
  return pigeonResult;
}
+ (Speed *)fromList:(NSArray *)list {
  Speed *pigeonResult = [[Speed alloc] init];
  pigeonResult.speed = [GetNullableObjectAtIndex(list, 0) doubleValue];
  return pigeonResult;
}
+ (nullable Speed *)nullableFromList:(NSArray *)list {
  return (list) ? [Speed fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.speed),
  ];
}
@end

@implementation Track
+ (instancetype)makeWithTitle:(NSString *)title
    description:(NSString *)description
    imageUrl:(NSString *)imageUrl
    artist:(nullable NSString *)artist
    artistUrl:(nullable NSString *)artistUrl {
  Track* pigeonResult = [[Track alloc] init];
  pigeonResult.title = title;
  pigeonResult.description = description;
  pigeonResult.imageUrl = imageUrl;
  pigeonResult.artist = artist;
  pigeonResult.artistUrl = artistUrl;
  return pigeonResult;
}
+ (Track *)fromList:(NSArray *)list {
  Track *pigeonResult = [[Track alloc] init];
  pigeonResult.title = GetNullableObjectAtIndex(list, 0);
  pigeonResult.description = GetNullableObjectAtIndex(list, 1);
  pigeonResult.imageUrl = GetNullableObjectAtIndex(list, 2);
  pigeonResult.artist = GetNullableObjectAtIndex(list, 3);
  pigeonResult.artistUrl = GetNullableObjectAtIndex(list, 4);
  return pigeonResult;
}
+ (nullable Track *)nullableFromList:(NSArray *)list {
  return (list) ? [Track fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.title ?: [NSNull null],
    self.description ?: [NSNull null],
    self.imageUrl ?: [NSNull null],
    self.artist ?: [NSNull null],
    self.artistUrl ?: [NSNull null],
  ];
}
@end

@interface MeditoAudioServiceApiCodecReader : FlutterStandardReader
@end
@implementation MeditoAudioServiceApiCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [AudioData fromList:[self readValue]];
    case 129: 
      return [Track fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface MeditoAudioServiceApiCodecWriter : FlutterStandardWriter
@end
@implementation MeditoAudioServiceApiCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[AudioData class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[Track class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface MeditoAudioServiceApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation MeditoAudioServiceApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[MeditoAudioServiceApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[MeditoAudioServiceApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *MeditoAudioServiceApiGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    MeditoAudioServiceApiCodecReaderWriter *readerWriter = [[MeditoAudioServiceApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpMeditoAudioServiceApi(id<FlutterBinaryMessenger> binaryMessenger, NSObject<MeditoAudioServiceApi> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.Medito.MeditoAudioServiceApi.playAudio"
        binaryMessenger:binaryMessenger
        codec:MeditoAudioServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(playAudioAudioData:error:)], @"MeditoAudioServiceApi api (%@) doesn't respond to @selector(playAudioAudioData:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        AudioData *arg_audioData = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSNumber *output = [api playAudioAudioData:arg_audioData error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.Medito.MeditoAudioServiceApi.playPauseAudio"
        binaryMessenger:binaryMessenger
        codec:MeditoAudioServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(playPauseAudioWithError:)], @"MeditoAudioServiceApi api (%@) doesn't respond to @selector(playPauseAudioWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api playPauseAudioWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.Medito.MeditoAudioServiceApi.stopAudio"
        binaryMessenger:binaryMessenger
        codec:MeditoAudioServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(stopAudioWithError:)], @"MeditoAudioServiceApi api (%@) doesn't respond to @selector(stopAudioWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api stopAudioWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.Medito.MeditoAudioServiceApi.setSpeed"
        binaryMessenger:binaryMessenger
        codec:MeditoAudioServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setSpeedSpeed:error:)], @"MeditoAudioServiceApi api (%@) doesn't respond to @selector(setSpeedSpeed:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        double arg_speed = [GetNullableObjectAtIndex(args, 0) doubleValue];
        FlutterError *error;
        [api setSpeedSpeed:arg_speed error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.Medito.MeditoAudioServiceApi.seekToPosition"
        binaryMessenger:binaryMessenger
        codec:MeditoAudioServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(seekToPositionPosition:error:)], @"MeditoAudioServiceApi api (%@) doesn't respond to @selector(seekToPositionPosition:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSInteger arg_position = [GetNullableObjectAtIndex(args, 0) integerValue];
        FlutterError *error;
        [api seekToPositionPosition:arg_position error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.Medito.MeditoAudioServiceApi.skip10SecondsForward"
        binaryMessenger:binaryMessenger
        codec:MeditoAudioServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(skip10SecondsForwardWithError:)], @"MeditoAudioServiceApi api (%@) doesn't respond to @selector(skip10SecondsForwardWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api skip10SecondsForwardWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.Medito.MeditoAudioServiceApi.skip10SecondsBackward"
        binaryMessenger:binaryMessenger
        codec:MeditoAudioServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(skip10SecondsBackwardWithError:)], @"MeditoAudioServiceApi api (%@) doesn't respond to @selector(skip10SecondsBackwardWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api skip10SecondsBackwardWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.Medito.MeditoAudioServiceApi.setBackgroundSound"
        binaryMessenger:binaryMessenger
        codec:MeditoAudioServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setBackgroundSoundUri:error:)], @"MeditoAudioServiceApi api (%@) doesn't respond to @selector(setBackgroundSoundUri:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_uri = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setBackgroundSoundUri:arg_uri error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.Medito.MeditoAudioServiceApi.setBackgroundSoundVolume"
        binaryMessenger:binaryMessenger
        codec:MeditoAudioServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setBackgroundSoundVolumeVolume:error:)], @"MeditoAudioServiceApi api (%@) doesn't respond to @selector(setBackgroundSoundVolumeVolume:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        double arg_volume = [GetNullableObjectAtIndex(args, 0) doubleValue];
        FlutterError *error;
        [api setBackgroundSoundVolumeVolume:arg_volume error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.Medito.MeditoAudioServiceApi.stopBackgroundSound"
        binaryMessenger:binaryMessenger
        codec:MeditoAudioServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(stopBackgroundSoundWithError:)], @"MeditoAudioServiceApi api (%@) doesn't respond to @selector(stopBackgroundSoundWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api stopBackgroundSoundWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.Medito.MeditoAudioServiceApi.playBackgroundSound"
        binaryMessenger:binaryMessenger
        codec:MeditoAudioServiceApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(playBackgroundSoundWithError:)], @"MeditoAudioServiceApi api (%@) doesn't respond to @selector(playBackgroundSoundWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api playBackgroundSoundWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface MeditoAudioServiceCallbackApiCodecReader : FlutterStandardReader
@end
@implementation MeditoAudioServiceCallbackApiCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [BackgroundSound fromList:[self readValue]];
    case 129: 
      return [PlaybackState fromList:[self readValue]];
    case 130: 
      return [Speed fromList:[self readValue]];
    case 131: 
      return [Track fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface MeditoAudioServiceCallbackApiCodecWriter : FlutterStandardWriter
@end
@implementation MeditoAudioServiceCallbackApiCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[BackgroundSound class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PlaybackState class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[Speed class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[Track class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface MeditoAudioServiceCallbackApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation MeditoAudioServiceCallbackApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[MeditoAudioServiceCallbackApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[MeditoAudioServiceCallbackApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *MeditoAudioServiceCallbackApiGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    MeditoAudioServiceCallbackApiCodecReaderWriter *readerWriter = [[MeditoAudioServiceCallbackApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

@interface MeditoAudioServiceCallbackApi ()
@property(nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation MeditoAudioServiceCallbackApi

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)updatePlaybackStateState:(PlaybackState *)arg_state completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = @"dev.flutter.pigeon.Medito.MeditoAudioServiceCallbackApi.updatePlaybackState";
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:channelName
      binaryMessenger:self.binaryMessenger
      codec:MeditoAudioServiceCallbackApiGetCodec()];
  [channel sendMessage:@[arg_state ?: [NSNull null]] reply:^(NSArray<id> *reply) {
    if (reply != nil) {
      if (reply.count > 1) {
        completion([FlutterError errorWithCode:reply[0] message:reply[1] details:reply[2]]);
      } else {
        completion(nil);
      }
    } else {
      completion(createConnectionError(channelName));
    } 
  }];
}
@end

